missing <- setdiff(cols, names(df))
if (length(missing)) for (m in missing) df[[m]] <- NA
df <- df[, cols, drop = FALSE]
df[] <- lapply(df, function(x) if (is.factor(x)) as.character(x) else x)
df
}
is_mixed_target_modal <- function(modal) modal %in% c("usually","rarely","25","75")
is_solid_target_modal <- function(modal) modal %in% c("always","never","0","100")
pick_images_by_modal <- function(d, object = c("wheel","marble"), modal) {
object <- match.arg(object)
stopifnot(xor(is_mixed_target_modal(modal), is_solid_target_modal(modal)))
if (object == "wheel") {
tgt <- if (is_mixed_target_modal(modal)) d$wheel_mixed else d$wheel_solid
cmp <- if (is_mixed_target_modal(modal)) d$wheel_solid else d$wheel_mixed
horiz <- if (is_mixed_target_modal(modal)) d$marble_mixed else d$marble_solid
other <- if (is_mixed_target_modal(modal)) d$marble_solid else d$marble_mixed
} else {
tgt <- if (is_mixed_target_modal(modal)) d$marble_mixed else d$marble_solid
cmp <- if (is_mixed_target_modal(modal)) d$marble_solid else d$marble_mixed
horiz <- if (is_mixed_target_modal(modal)) d$wheel_mixed else d$wheel_solid
other <- if (is_mixed_target_modal(modal)) d$wheel_solid else d$wheel_mixed
}
list(target=tgt, competitor=cmp, horiz=horiz, other=other)
}
# 6) Sentence & instruction builder (ALL trials) -------------------------------
add_sentences_to_list <- function(df, displays) {
for (nm in c("color_pair","marble_orientation","wheel_option"))
if (!nm %in% names(df)) df[[nm]] <- NA_character_
meta <- displays %>%
select(display_id, color_pair, marble_orientation, wheel_option) %>%
rename(color_pair_meta=color_pair,
marble_orientation_meta=marble_orientation,
wheel_option_meta=wheel_option)
dd <- df %>%
left_join(meta, by="display_id") %>%
mutate(
color_pair         = coalesce(.data$color_pair,         .data$color_pair_meta),
marble_orientation = coalesce(.data$marble_orientation, .data$marble_orientation_meta),
wheel_option       = coalesce(.data$wheel_option,       .data$wheel_option_meta)
) %>%
select(-ends_with("_meta")) %>%
mutate(
color_pair         = as.character(.data$color_pair),
marble_orientation = as.character(.data$marble_orientation),
wheel_option       = as.character(.data$wheel_option),
target_object      = as.character(.data$target_object),
condition          = as.character(.data$condition),
modal              = as.character(.data$modal)
)
color_word <- function(c) c(b="blue", g="green", y="yellow")[c]
safe_split_pair   <- function(cp) if (is.na(cp) || !nzchar(cp)) c(NA,NA) else strsplit(cp, "-", TRUE)[[1]]
safe_split_orient <- function(o)  if (is.na(o)  || !nzchar(o))  c(NA,NA) else strsplit(o,  "->", TRUE)[[1]]
make_sentence_and_instr <- function(subj, cond, mod, pair, m_or, wopt, target_obj) {
w_or <- if (identical(wopt, "same")) m_or else rev(m_or)
if (identical(target_obj, "wheel")) { obj_minor <- w_or[1]; obj_major <- w_or[2] }
else                                { obj_minor <- m_or[1]; obj_major <- m_or[2] }
obj_solid <- obj_minor
other_in_pair <- setdiff(pair, obj_solid); other_in_pair <- if (length(other_in_pair)) other_in_pair[1] else NA_character_
color_code <- if (identical(cond, "exp")) {
switch(mod, "usually"=obj_major, "rarely"=obj_minor, "always"=obj_solid, "never"=other_in_pair, NA_character_)
} else {
switch(as.character(mod), "25"=obj_minor, "75"=obj_major, "100"=obj_solid, "0"=other_in_pair, NA_character_)
}
if (is.na(color_code)) return(c(NA_character_, NA_character_))
cw <- color_word(color_code)
if (identical(cond, "exp")) {
s <- paste0(subj, " ", mod, " lands on ", cw, ".")
instr <- paste0("The |", tolower(sub("The ", "", subj)), " |", mod, " lands on |", cw, ".")
} else {
s <- paste0(subj, " has a ", as.character(mod), " percent chance of landing on ", cw, ".")
instr <- paste0("The |", tolower(sub("The ", "", subj)), " |has a ", as.character(mod),
" percent chance of landing on |", cw, ".")
}
c(s, instr)
}
out_sentence <- character(nrow(dd)); out_instruction <- character(nrow(dd))
for (i in seq_len(nrow(dd))) {
subj <- if (identical(dd$target_object[i], "wheel")) "The arrow" else "The marble"
pair <- safe_split_pair(dd$color_pair[i])
mor  <- safe_split_orient(dd$marble_orientation[i])
if (any(is.na(c(pair, mor)))) { out_sentence[i] <- NA_character_; out_instruction[i] <- NA_character_; next }
s_i <- make_sentence_and_instr(subj, dd$condition[i], dd$modal[i], pair, mor, dd$wheel_option[i], dd$target_object[i])
out_sentence[i]    <- s_i[1]
out_instruction[i] <- s_i[2]
}
dd$sentence    <- out_sentence
dd$instruction <- out_instruction
dd
}
# 7) Robust locations -----------------------------------------------------------
add_target_comp_loc <- function(df) {
cols <- c("LT","RT","LB","RB")
to_chr <- function(x) if (is.factor(x)) as.character(x) else x
for (nm in c(cols, "target_image", "competitor_image")) {
if (!nm %in% names(df)) df[[nm]] <- NA_character_
df[[nm]] <- to_chr(df[[nm]])
}
find_loc <- function(row_imgs, img) {
if (is.na(img) || all(is.na(row_imgs))) return(NA_character_)
hits <- which(row_imgs == img)
if (length(hits) >= 1) names(row_imgs)[hits[1]] else NA_character_
}
df$target_loc <- vapply(seq_len(nrow(df)), function(i) find_loc(df[i, c("LT","RT","LB","RB")], df$target_image[i]), character(1))
df$competitor_loc <- vapply(seq_len(nrow(df)), function(i) find_loc(df[i, c("LT","RT","LB","RB")], df$competitor_image[i]), character(1))
df
}
# 8) Base-24 trial builders -----------------------------------------------------
make_experiment_trials_for_list <- function(displays, list_id) {
n_disp <- nrow(displays); n_trials <- 2L * n_disp
tpos <- balanced_positions(n_trials)
mods <- c("always","usually","rarely","never")
rows <- vector("list", n_trials); k <- 1L
for (i in seq_len(n_disp)) {
d <- displays[i, ]
base <- (i - 1) %% length(mods)
wheel_mod  <- mods[((base + (list_id - 1))     %% 4) + 1]
marble_mod <- mods[((base + (list_id - 1) + 2) %% 4) + 1]
imgs <- pick_images_by_modal(d, "wheel", wheel_mod)
pos  <- place_images(imgs$target, imgs$competitor, imgs$horiz, imgs$other, tpos[k])
rows[[k]] <- data.frame(
list_id=list_id, display_id=d$display_id, condition="exp",
target_object="wheel", modal=wheel_mod,
target_image=imgs$target, competitor_image=imgs$competitor,
other1_image=imgs$horiz,  other2_image=imgs$other,
LT=pos["LT"], RT=pos["RT"], LB=pos["LB"], RB=pos["RB"],
item_id=paste0(d$display_id, "_wheel"), stringsAsFactors = FALSE
); k <- k + 1L
imgs <- pick_images_by_modal(d, "marble", marble_mod)
pos  <- place_images(imgs$target, imgs$competitor, imgs$horiz, imgs$other, tpos[k])
rows[[k]] <- data.frame(
list_id=list_id, display_id=d$display_id, condition="exp",
target_object="marble", modal=marble_mod,
target_image=imgs$target, competitor_image=imgs$competitor,
other1_image=imgs$horiz,  other2_image=imgs$other,
LT=pos["LT"], RT=pos["RT"], LB=pos["LB"], RB=pos["RB"],
item_id=paste0(d$display_id, "_marble"), stringsAsFactors = FALSE
); k <- k + 1L
}
do.call(rbind, rows)
}
make_numeric_fillers_from_displays <- function(displays_subset, list_id) {
stopifnot(nrow(displays_subset) == 4L)
numerals <- c("0","25","75","100")
tpos <- balanced_positions(2L * nrow(displays_subset))
out <- vector("list", 2L * nrow(displays_subset)); k <- 1L
for (i in seq_len(nrow(displays_subset))) {
d <- displays_subset[i, ]; num <- numerals[i]
imgs <- pick_images_by_modal(d, "wheel", modal=num)
pos  <- place_images(imgs$target, imgs$competitor, imgs$horiz, imgs$other, tpos[k])
out[[k]] <- data.frame(
list_id=list_id, display_id=d$display_id, condition="filler",
target_object="wheel", modal=num,
target_image=imgs$target, competitor_image=imgs$competitor,
other1_image=imgs$horiz,  other2_image=imgs$other,
LT=pos["LT"], RT=pos["RT"], LB=pos["LB"], RB=pos["RB"],
item_id=paste0(d$display_id, "_wheel"), stringsAsFactors = FALSE
); k <- k + 1L
imgs <- pick_images_by_modal(d, "marble", modal=num)
pos  <- place_images(imgs$target, imgs$competitor, imgs$horiz, imgs$other, tpos[k])
out[[k]] <- data.frame(
list_id=list_id, display_id=d$display_id, condition="filler",
target_object="marble", modal=num,
target_image=imgs$target, competitor_image=imgs$competitor,
other1_image=imgs$horiz,  other2_image=imgs$other,
LT=pos["LT"], RT=pos["RT"], LB=pos["LB"], RB=pos["RB"],
item_id=paste0(d$display_id, "_marble"), stringsAsFactors = FALSE
); k <- k + 1L
}
do.call(rbind, out)
}
# 9) Variant-wise pair targets for base 24 -------------------------------------
desired_exp_display_counts <- function(variant) {
# 8 EXP displays per list -> 3/3/2 by pair
switch(variant,
"V1" = c("b-g"=3, "b-y"=3, "g-y"=2),
"V2" = c("b-g"=3, "b-y"=2, "g-y"=3),
"V3" = c("b-g"=2, "b-y"=3, "g-y"=3))
}
desired_fill_display_counts <- function(variant) {
# 4 FILLER displays per list -> 1/1/2 by pair
switch(variant,
"V1" = c("b-g"=1, "b-y"=1, "g-y"=2),
"V2" = c("b-g"=1, "b-y"=2, "g-y"=1),
"V3" = c("b-g"=2, "b-y"=1, "g-y"=1))
}
# 10) GLOBAL FILLER SOLVER (core) ----------------------------------------------
# Build, for each variant/list, the set of 4-display candidate filler sets that
# satisfy the 1/1/2 counts for that variant. Then pick one candidate per list
# over all 12 lists so each display_id is used exactly 4 times as a filler.
.make_candidates_for_variant <- function(displays, variant) {
ids <- displays$display_id
cp  <- setNames(displays$color_pair, displays$display_id)
need <- desired_fill_display_counts(variant)
lev  <- names(need)
# all 4-combinations of 12 ids
combs <- combn(ids, 4, simplify = FALSE)
ok <- lapply(combs, function(v) {
got <- table(factor(cp[as.character(v)], levels = lev))
if (all(as.integer(got) == as.integer(need))) sort(v) else NULL
})
Filter(Negate(is.null), ok)
}
# Backtracking exact cover to hit "each display used 4× as filler"
.solve_global_fillers <- function(displays) {
# 12 lists = 3 variants × 4 lists
lists <- expand.grid(variant=c("V1","V2","V3"), list_id=1:4, KEEP.OUT.ATTRS = FALSE) %>%
arrange(variant, list_id)
# Precompute candidates per (variant,list)
cands <- vector("list", nrow(lists))
names(cands) <- paste0(lists$variant, "_", lists$list_id)
for (i in seq_len(nrow(lists))) {
v <- lists$variant[i]
cand_sets <- .make_candidates_for_variant(displays, v)
if (!length(cand_sets)) stop("No 4-display candidate sets for ", v)
cands[[i]] <- cand_sets
}
# Heuristic: order lists by fewest candidates to prune early
ord <- order(vapply(cands, length, integer(1L)))
lists <- lists[ord, , drop=FALSE]
cands <- cands[ord]
remaining <- setNames(rep(4L, nrow(displays)), displays$display_id)  # each display: 4 slots
choice_idx <- integer(nrow(lists))
solutions <- NULL
used_cache <- new.env(parent = emptyenv())
feasible <- function(set) all(remaining[as.character(set)] > 0)
backtrack <- function(depth=1L) {
if (depth > nrow(lists)) { solutions <<- choice_idx; return(TRUE) }
key <- paste(remaining, collapse="|")
if (!is.null(used_cache[[key]])) return(FALSE)
cs <- cands[[depth]]
# greedy: try candidates that use higher-remaining displays first
score <- vapply(cs, function(v) sum(remaining[as.character(v)]), integer(1))
try_order <- order(-score)
for (k in try_order) {
v <- cs[[k]]
if (!feasible(v)) next
remaining[as.character(v)] <<- remaining[as.character(v)] - 1L
choice_idx[depth] <<- k
if (backtrack(depth+1L)) return(TRUE)
remaining[as.character(v)] <<- remaining[as.character(v)] + 1L
}
used_cache[[key]] <- TRUE
return(FALSE)
}
ok <- backtrack(1L)
if (!ok) stop("Global filler assignment failed to meet 4× per display.")
# Build a tidy result table: for each (variant,list) which 4 displays are fillers
out <- lists
out$candidate_index <- solutions
out$filler_displays <- mapply(function(i, k) paste(cands[[i]][[k]], collapse=","), seq_along(cands), solutions)
# restore natural order by variant then list_id
out <- out %>% arrange(variant, list_id)
out
}
# 11) Build base-24 using the global filler solution ---------------------------
build_all_base24_with_global_fillers <- function(displays) {
plan <- .solve_global_fillers(displays)
lists_out <- list(V1=list(), V2=list(), V3=list())
for (v in c("V1","V2","V3")) {
vplan <- plan %>% filter(variant==v)
for (L in 1:4) {
row <- vplan %>% filter(list_id==L)
fil_ids <- as.integer(strsplit(row$filler_displays, ",", TRUE)[[1]])
exp_ids <- setdiff(displays$display_id, fil_ids)
# sanity: pair distributions
# fillers 1/1/2 by variant
needF <- desired_fill_display_counts(v)
gotF  <- table(factor(displays$color_pair[match(fil_ids, displays$display_id)], levels=names(needF)))
if (!all(as.integer(gotF)==as.integer(needF))) stop("Filler pattern mismatch in ", v, " L", L)
# EXP will be complement => 3/3/2 automatically because totals per pair across 12 displays are 4/4/4
needE <- desired_exp_display_counts(v)
gotE  <- table(factor(displays$color_pair[match(exp_ids, displays$display_id)], levels=names(needE)))
if (!all(as.integer(gotE)==as.integer(needE))) stop("EXP pattern mismatch in ", v, " L", L)
exp_df <- make_experiment_trials_for_list(displays[displays$display_id %in% exp_ids, , drop=FALSE], list_id = L)
num_df <- make_numeric_fillers_from_displays(displays[displays$display_id %in% fil_ids, , drop=FALSE], list_id = L)
all_cols <- union(names(exp_df), names(num_df))
exp_df <- align_cols(exp_df, all_cols)
num_df <- align_cols(num_df, all_cols)
base24 <- rbind(exp_df, num_df) %>%
mutate(list_name=paste0("List", L),
trial_in_list = seq_len(n()),
variant = v)
lists_out[[v]][[paste0("List",L)]] <- base24
}
}
lists_out
}
# 12) TYPE-B (built completely separate) ---------------------------------------
.typeB_slots <- function() {
data.frame(
modal = c("25","25","75","75","100","100","0","0"),
target_object = rep(c("wheel","marble"), times = 4),
stringsAsFactors = FALSE
) %>% dplyr::mutate(slot_index = dplyr::row_number())
}
A_idx <- c(1,2,5,6); B_idx <- c(3,4,7,8)
.make_assign_vec_strict <- function(counts_named, list_id, variant) {
stopifnot(sum(counts_named) == 8L)
assign <- rep(NA_character_, 8)
base_pref <- switch(variant,
"V1" = c("b-g","b-y","g-y"),
"V2" = c("b-y","g-y","b-g"),
"V3" = c("g-y","b-g","b-y"),
c("b-g","b-y","g-y"))
shift <- (as.integer(list_id) - 1L) %% length(base_pref)
if (shift > 0) base_pref <- c(base_pref[(shift+1):length(base_pref)], base_pref[1:shift])
put <- function(pair, n, pool_idx) {
free <- pool_idx[is.na(assign[pool_idx])]
if (length(free) < n) stop("Not enough free slots for strict assignment (", pair, ").")
assign[free[seq_len(n)]] <<- pair
}
k3 <- names(counts_named)[counts_named == 3L]
k2 <- names(counts_named)[counts_named == 2L]
if (length(k3) == 2L) {
A_heavy <- base_pref[base_pref %in% k3][1]
B_heavy <- setdiff(k3, A_heavy)
put(A_heavy, 2, A_idx); put(A_heavy, 1, B_idx)
put(B_heavy, 1, A_idx); put(B_heavy, 2, B_idx)
} else if (length(k3) == 1L) {
put(k3, 2, A_idx); put(k3, 1, B_idx)
}
if (length(k2) == 1L) { put(k2, 1, A_idx); put(k2, 1, B_idx) }
got <- table(factor(assign, levels = names(counts_named)))
if (!all(as.integer(got) == as.integer(counts_named))) stop("Strict assignment failed.")
if (sum(!is.na(assign[A_idx])) != 4L || sum(!is.na(assign[B_idx])) != 4L) stop("A/B slot balance error.")
assign
}
build_typeB_from_assignment <- function(assign_pairs_vec, start_display_id = 13L) {
stopifnot(length(assign_pairs_vec)==8L)
slots <- .typeB_slots(); tpos <- typeB_positions()
to_pair <- function(s) strsplit(s, "-", TRUE)[[1]]
rows <- vector("list", 8L)
for (i in 1:8) {
c12 <- to_pair(assign_pairs_vec[i]); c1 <- c12[1]; c2 <- c12[2]
m <- slots$modal[i]; obj <- slots$target_object[i]
wh_s1 <- solid_img("wheel",  c1); wh_s2 <- solid_img("wheel",  c2)
mb_s1 <- solid_img("marble", c1); mb_s2 <- solid_img("marble", c2)
mb_12 <- mixed_img("marble", c1, c2); mb_21 <- mixed_img("marble", c2, c1)
wh_12 <- mixed_img("wheel",  c1, c2); wh_21 <- mixed_img("wheel",  c2, c1)
if (obj == "wheel") {
if (m %in% c("25","75")) { tgt<-wh_12; cmp<-wh_21; horiz<-mb_s1; other<-mb_s2 }
else                     { tgt<-wh_s1;  cmp<-wh_s2;  horiz<-mb_12; other<-mb_21 }
} else {
if (m %in% c("25","75")) { tgt<-mb_12; cmp<-mb_21; horiz<-wh_s1; other<-wh_s2 }
else                     { tgt<-mb_s1;  cmp<-mb_s2;  horiz<-wh_12; other<-wh_21 }
}
pos <- place_images(tgt, cmp, horiz, other, tpos[i])
rows[[i]] <- data.frame(
list_id = NA_integer_, list_name = NA_character_,
display_id = start_display_id + (i - 1L),
condition = "typeB",
target_object = obj, modal = m,
sentence = NA_character_, instruction = NA_character_,
target_image=tgt, competitor_image=cmp, other1_image=horiz, other2_image=other,
LT=pos["LT"], RT=pos["RT"], LB=pos["LB"], RB=pos["RB"],
color_pair = paste(sort(c(c1,c2)), collapse="-"),
marble_orientation = paste0(c1,"->",c2), wheel_option="same",
item_id = paste0(start_display_id + (i - 1L), "_", obj), stringsAsFactors = FALSE
)
}
do.call(rbind, rows)
}
.typeB_counts_for_variant <- function(variant) {
switch(variant,
"V1" = c("b-g"=3,"b-y"=3,"g-y"=2),
"V2" = c("b-g"=2,"b-y"=3,"g-y"=3),
"V3" = c("b-g"=3,"b-y"=2,"g-y"=3))
}
build_typeB_across_variants <- function() {
out <- list(V1=vector("list",4), V2=vector("list",4), V3=vector("list",4))
names(out$V1) <- names(out$V2) <- names(out$V3) <- paste0("List",1:4)
for (L in 1:4) {
for (v in c("V1","V2","V3")) {
counts <- .typeB_counts_for_variant(v)
assign_vec <- .make_assign_vec_strict(counts, list_id=L, variant=v)
tb <- build_typeB_from_assignment(assign_vec, start_display_id=13L) %>%
mutate(list_id=L, list_name=paste0("List",L), variant=v)
out[[v]][[L]] <- tb
}
}
out
}
# 13) Build base-24 (global fillers), then Type-B, append ----------------------
base_all <- build_all_base24_with_global_fillers(displays)
lists_V1_base <- base_all$V1
lists_V2_base <- base_all$V2
lists_V3_base <- base_all$V3
typeB_sets <- build_typeB_across_variants()
typeB_V1 <- typeB_sets$V1; typeB_V2 <- typeB_sets$V2; typeB_V3 <- typeB_sets$V3
append_typeB_per_list <- function(lists_base24, typeB_sets, variant_label) {
out <- vector("list", length(lists_base24)); names(out) <- names(lists_base24)
for (i in seq_along(lists_base24)) {
base24 <- lists_base24[[i]]
tb     <- typeB_sets[[i]]
tb$variant <- variant_label
all_cols <- union(names(base24), names(tb))
base24 <- align_cols(base24, all_cols)
tb     <- align_cols(tb, all_cols)
merged <- rbind(base24, tb)
merged$trial_in_list <- seq_len(nrow(merged))
out[[i]] <- merged
}
out
}
lists_V1 <- append_typeB_per_list(lists_V1_base, typeB_V1, "V1")
lists_V2 <- append_typeB_per_list(lists_V2_base, typeB_V2, "V2")
lists_V3 <- append_typeB_per_list(lists_V3_base, typeB_V3, "V3")
# 14) Re-balance target corners for base trials only (leave Type-B intact) -----
.positions_for_n <- function(n) {
base4 <- c("LT","RT","LB","RB")
full_cycles <- n %/% 4; remainder <- n %% 4
v <- rep(base4, full_cycles)
if (remainder > 0) v <- c(v, sample(base4, remainder))
sample(v)
}
enforce_modal_balanced_target_positions <- function(df, skip_condition = "typeB") {
stopifnot(all(c("modal","target_image","competitor_image","other1_image","other2_image") %in% names(df)))
idx_use <- which(df$condition != skip_condition)  # leave Type-B rows untouched
new_LT <- df$LT; new_RT <- df$RT; new_LB <- df$LB; new_RB <- df$RB
idx_by_modal <- split(idx_use, as.character(df$modal[idx_use]))
for (m in names(idx_by_modal)) {
idx <- idx_by_modal[[m]]
pos_vec <- .positions_for_n(length(idx))
for (j in seq_along(idx)) {
i <- idx[j]; tp <- pos_vec[j]
lay <- place_images(df$target_image[i], df$competitor_image[i], df$other1_image[i], df$other2_image[i], tp)
new_LT[i] <- lay["LT"]; new_RT[i] <- lay["RT"]; new_LB[i] <- lay["LB"]; new_RB[i] <- lay["RB"]
}
}
df$LT <- new_LT; df$RT <- new_RT; df$LB <- new_LB; df$RB <- new_RB
df
}
lists_V1 <- lapply(lists_V1, enforce_modal_balanced_target_positions)
lists_V2 <- lapply(lists_V2, enforce_modal_balanced_target_positions)
lists_V3 <- lapply(lists_V3, enforce_modal_balanced_target_positions)
# 15) Sentence & instruction for ALL trials; compute locations -----------------
lists_V1 <- lapply(lists_V1, add_sentences_to_list, displays = displays)
lists_V2 <- lapply(lists_V2, add_sentences_to_list, displays = displays)
lists_V3 <- lapply(lists_V3, add_sentences_to_list, displays = displays)
lists_V1 <- lapply(lists_V1, add_target_comp_loc)
lists_V2 <- lapply(lists_V2, add_target_comp_loc)
lists_V3 <- lapply(lists_V3, add_target_comp_loc)
# 16) Diagnostics ---------------------------------------------------------------
count_pairs_section <- function(df, cond, displays) {
df %>%
filter(condition==cond) %>%
count(display_id) %>%
left_join(displays %>% select(display_id, color_pair), by="display_id") %>%
count(color_pair, name="n")
}
count_pairs_TypeB <- function(df) df %>% filter(condition=="typeB") %>% count(color_pair)
# Base EXP (expect 6/6/4, i.e., 3/3/2 displays):
cat("\nBASE-24: EXP pair counts per list (expect 6/6/4 trials = 3/3/2 displays):\n")
invisible(lapply(lists_V1_base, function(df) print(count_pairs_section(df, "exp", displays))))
invisible(lapply(lists_V2_base, function(df) print(count_pairs_section(df, "exp", displays))))
invisible(lapply(lists_V3_base, function(df) print(count_pairs_section(df, "exp", displays))))
# Base FILLER (expect 2/2/4 trials = 1/1/2 displays):
cat("\nBASE-24: FILLER pair counts per list (expect 2/2/4 trials = 1/1/2 displays):\n")
invisible(lapply(lists_V1_base, function(df) print(count_pairs_section(df, "filler", displays))))
invisible(lapply(lists_V2_base, function(df) print(count_pairs_section(df, "filler", displays))))
invisible(lapply(lists_V3_base, function(df) print(count_pairs_section(df, "filler", displays))))
# Type-B (expect 3/3/2):
cat("\nTYPE-B: pair counts per list (expect 3/3/2):\n")
invisible(lapply(lists_V1, function(df) print(count_pairs_TypeB(df))))
invisible(lapply(lists_V2, function(df) print(count_pairs_TypeB(df))))
invisible(lapply(lists_V3, function(df) print(count_pairs_TypeB(df))))
# Global filler usage check: each display_id used 4× as filler across 12 lists
global_filler_usage <- bind_rows(
bind_rows(lists_V1_base, .id="which_list") %>% mutate(variant="V1"),
bind_rows(lists_V2_base, .id="which_list") %>% mutate(variant="V2"),
bind_rows(lists_V3_base, .id="which_list") %>% mutate(variant="V3")
) %>%
filter(condition=="filler") %>%
count(display_id)
cat("\nGlobal numeric FILLER usage per display_id (expect all 12 equal to 4):\n")
print(global_filler_usage)
# Global item_id usage as filler (wheel/marble) should be 4× each -> 24 items × 4 = 96
global_item_filler_usage <- bind_rows(
bind_rows(lists_V1_base, .id="which_list") %>% mutate(variant="V1"),
bind_rows(lists_V2_base, .id="which_list") %>% mutate(variant="V2"),
bind_rows(lists_V3_base, .id="which_list") %>% mutate(variant="V3")
) %>%
filter(condition=="filler") %>%
count(item_id)
cat("\nGlobal numeric FILLER usage per item_id (expect all 24 equal to 4):\n")
print(global_item_filler_usage)
# 17) Write CSVs ----------------------------------------------------------------
write_variant_csvs <- function(lists, variant_label, out_dir = "lists_out") {
dir.create(out_dir, showWarnings = FALSE, recursive = TRUE)
comb <- list()
for (nm in names(lists)) {
df <- lists[[nm]]
fn <- file.path(out_dir, paste0(variant_label, "_", nm, ".csv"))
write.csv(df, fn, row.names = FALSE)
comb[[nm]] <- df
}
combined <- bind_rows(comb, .id="which_list")
fn_all <- file.path(out_dir, paste0(variant_label, "_all_lists.csv"))
write.csv(combined, fn_all, row.names = FALSE)
invisible(combined)
}
comb_V1 <- write_variant_csvs(lists_V1, "V1")
comb_V2 <- write_variant_csvs(lists_V2, "V2")
comb_V3 <- write_variant_csvs(lists_V3, "V3")
all_variants_combined <- bind_rows(
comb_V1 %>% mutate(variant="V1"),
comb_V2 %>% mutate(variant="V2"),
comb_V3 %>% mutate(variant="V3")
)
write.csv(all_variants_combined, file.path("lists_out", "ALL_variants_all_lists.csv"), row.names = FALSE)
cat("\nDone.\n- Base EXP/FILLER pair distributions are 3/3/2 and 1/1/2 (6/6/4 and 2/2/4 trials), rotating across variants.\n- Global solver ensures each base item_id is a FILLER exactly 4× overall (24×4=96 filler trials).\n- Type-B is 3/3/2 per list, one wheel+marble per modal, corners balanced.\n- All trials include sentence + instruction; locations are filled.\nFiles in ./lists_out\n")
warnings()
